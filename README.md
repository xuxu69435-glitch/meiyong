1. 实践背景与目标
本实践基于 MIT xv6 (x86版本)，旨在通过代码实现和调试，深入理解操作系统从引导程序（bootloader）到内核 main 函数的完整启动链路 。



实践目标包括：

理解 xv6 启动链路：bootasm.S → bootmain.c → entry.S → main() 。

掌握汇编与 C 语言在启动阶段的协作方式 。

实现启动过程的可视化打印 。

2. xv6 启动流程说明 

根据代码分析与注释任务，xv6 的启动经过以下关键节点：


bootasm.S: 计算机加电后首先运行的代码。负责开启 A20 总线，并从 16 位实模式切换到 32 位保护模式 。




bootmain.c: 进入 C 语言环境。负责从硬盘读取 ELF 格式的内核镜像并将其加载到内存中 。




entry.S: 内核的入口点。负责设置初始页表并开启分页机制，最后跳转到内核的 main 函数 。



main.c: 执行内核初始化工作 。

3. 启动过程可视化（运行结果）
在本次实践中，我在关键启动节点插入了 cprintf 调试信息 。执行 make qemu 成功启动系统后，终端输出如下验证信息：


Plaintext

[BOOT] enter bootmain      // 成功进入 bootmain.c [cite: 25]
[BOOT] elf header loaded   // ELF 头部信息读取成功 [cite: 26]
[BOOT] kernel loaded       // 内核镜像完整加载到内存 [cite: 27]
[KERNEL] main() started    // 成功跳转并启动内核 main() 
4. 个人总结 

通过本次读书实践周的任务，我有以下几点收获：


理解了软硬协作：通过修改 bootasm.S 和 bootmain.c，我直观地看到了汇编如何为 C 语言环境搭建舞台 。


掌握了镜像加载：深入理解了 ELF 格式内核镜像如何从磁盘被正确放置到内存特定位置的过程 。


提升了调试能力：学会在没有图形界面的内核开发环境下，利用打印信息进行逻辑验证和错误排查 。
